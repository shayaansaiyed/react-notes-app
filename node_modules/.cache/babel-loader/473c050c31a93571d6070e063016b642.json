{"ast":null,"code":"/* globals chrome: false */\n\n/* globals __dirname: false */\n\n/* globals require: false */\n\n/* globals Buffer: false */\n\n/* globals module: false */\n\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \n * dictionaries.\n */\nvar Typo;\n\n(function () {\n  \"use strict\";\n  /**\n   * Typo constructor.\n   *\n   * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\n   *                              \"en_US\". This is only used to auto-load dictionaries.\n   * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .aff\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n   * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .dic\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n   * @param {Object} [settings]   Constructor settings. Available properties are:\n   *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\n   *                              environment.\n   *                              {Object} [flags]: flag information.\n   *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n   *                              asynchronously.\n   *                              {Function} [loadedCallback]: Called when both affData and wordsData\n   *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n   *                              is the instantiated Typo object.\n   *\n   * @returns {Typo} A Typo object.\n   */\n\n  Typo = function Typo(dictionary, affData, wordsData, settings) {\n    settings = settings || {};\n    this.dictionary = null;\n    this.rules = {};\n    this.dictionaryTable = {};\n    this.compoundRules = [];\n    this.compoundRuleCodes = {};\n    this.replacementTable = [];\n    this.flags = settings.flags || {};\n    this.memoized = {};\n    this.loaded = false;\n    var self = this;\n    var path; // Loop-control variables.\n\n    var i, j, _len, _jlen;\n\n    if (dictionary) {\n      self.dictionary = dictionary; // If the data is preloaded, just setup the Typo object.\n\n      if (affData && wordsData) {\n        setup();\n      } // Loading data for Chrome extentions.\n      else if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\n          if (settings.dictionaryPath) {\n            path = settings.dictionaryPath;\n          } else {\n            path = \"typo/dictionaries\";\n          }\n\n          if (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n          if (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n        } else {\n          if (settings.dictionaryPath) {\n            path = settings.dictionaryPath;\n          } else if (typeof __dirname !== 'undefined') {\n            path = __dirname + '/dictionaries';\n          } else {\n            path = './dictionaries';\n          }\n\n          if (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n          if (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n        }\n    }\n\n    function readDataFile(url, setFunc) {\n      var response = self._readFile(url, null, settings.asyncLoad);\n\n      if (settings.asyncLoad) {\n        response.then(function (data) {\n          setFunc(data);\n        });\n      } else {\n        setFunc(response);\n      }\n    }\n\n    function setAffData(data) {\n      affData = data;\n\n      if (wordsData) {\n        setup();\n      }\n    }\n\n    function setWordsData(data) {\n      wordsData = data;\n\n      if (affData) {\n        setup();\n      }\n    }\n\n    function setup() {\n      self.rules = self._parseAFF(affData); // Save the rule codes that are used in compound rules.\n\n      self.compoundRuleCodes = {};\n\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var rule = self.compoundRules[i];\n\n        for (j = 0, _jlen = rule.length; j < _jlen; j++) {\n          self.compoundRuleCodes[rule[j]] = [];\n        }\n      } // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n      // will do the work of saving the list of words that are compound-only.\n\n\n      if (\"ONLYINCOMPOUND\" in self.flags) {\n        self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n      }\n\n      self.dictionaryTable = self._parseDIC(wordsData); // Get rid of any codes from the compound rule codes that are never used \n      // (or that were special regex characters).  Not especially necessary... \n\n      for (i in self.compoundRuleCodes) {\n        if (self.compoundRuleCodes[i].length === 0) {\n          delete self.compoundRuleCodes[i];\n        }\n      } // Build the full regular expressions for each compound rule.\n      // I have a feeling (but no confirmation yet) that this method of \n      // testing for compound words is probably slow.\n\n\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var ruleText = self.compoundRules[i];\n        var expressionText = \"\";\n\n        for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n          var character = ruleText[j];\n\n          if (character in self.compoundRuleCodes) {\n            expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n          } else {\n            expressionText += character;\n          }\n        }\n\n        self.compoundRules[i] = new RegExp(expressionText, \"i\");\n      }\n\n      self.loaded = true;\n\n      if (settings.asyncLoad && settings.loadedCallback) {\n        settings.loadedCallback(self);\n      }\n    }\n\n    return this;\n  };\n\n  Typo.prototype = {\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load: function load(obj) {\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          this[i] = obj[i];\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Read the contents of a file.\n     * \n     * @param {String} path The path (relative) to the file.\n     * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     *        files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     *          always returned.\n     */\n    _readFile: function _readFile(path, charset, async) {\n      charset = charset || \"utf8\";\n\n      if (typeof XMLHttpRequest !== 'undefined') {\n        var promise;\n        var req = new XMLHttpRequest();\n        req.open(\"GET\", path, async);\n\n        if (async) {\n          promise = new Promise(function (resolve, reject) {\n            req.onload = function () {\n              if (req.status === 200) {\n                resolve(req.responseText);\n              } else {\n                reject(req.statusText);\n              }\n            };\n\n            req.onerror = function () {\n              reject(req.statusText);\n            };\n          });\n        }\n\n        if (req.overrideMimeType) req.overrideMimeType(\"text/plain; charset=\" + charset);\n        req.send(null);\n        return async ? promise : req.responseText;\n      } else if (typeof require !== 'undefined') {\n        // Node.js\n        var fs = require(\"fs\");\n\n        try {\n          if (fs.existsSync(path)) {\n            var stats = fs.statSync(path);\n            var fileDescriptor = fs.openSync(path, 'r');\n            var buffer = new Buffer(stats.size);\n            fs.readSync(fileDescriptor, buffer, 0, buffer.length, null);\n            return buffer.toString(charset, 0, buffer.length);\n          } else {\n            console.log(\"Path \" + path + \" does not exist.\");\n          }\n        } catch (e) {\n          console.log(e);\n          return '';\n        }\n      }\n    },\n\n    /**\n     * Parse the rules out from a .aff file.\n     *\n     * @param {String} data The contents of the affix file.\n     * @returns object The rules from the file.\n     */\n    _parseAFF: function _parseAFF(data) {\n      var rules = {};\n      var line, subline, numEntries, lineParts;\n\n      var i, j, _len, _jlen; // Remove comment lines\n\n\n      data = this._removeAffixComments(data);\n      var lines = data.split(\"\\n\");\n\n      for (i = 0, _len = lines.length; i < _len; i++) {\n        line = lines[i];\n        var definitionParts = line.split(/\\s+/);\n        var ruleType = definitionParts[0];\n\n        if (ruleType == \"PFX\" || ruleType == \"SFX\") {\n          var ruleCode = definitionParts[1];\n          var combineable = definitionParts[2];\n          numEntries = parseInt(definitionParts[3], 10);\n          var entries = [];\n\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            subline = lines[j];\n            lineParts = subline.split(/\\s+/);\n            var charactersToRemove = lineParts[2];\n            var additionParts = lineParts[3].split(\"/\");\n            var charactersToAdd = additionParts[0];\n            if (charactersToAdd === \"0\") charactersToAdd = \"\";\n            var continuationClasses = this.parseRuleCodes(additionParts[1]);\n            var regexToMatch = lineParts[4];\n            var entry = {};\n            entry.add = charactersToAdd;\n            if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n\n            if (regexToMatch !== \".\") {\n              if (ruleType === \"SFX\") {\n                entry.match = new RegExp(regexToMatch + \"$\");\n              } else {\n                entry.match = new RegExp(\"^\" + regexToMatch);\n              }\n            }\n\n            if (charactersToRemove != \"0\") {\n              if (ruleType === \"SFX\") {\n                entry.remove = new RegExp(charactersToRemove + \"$\");\n              } else {\n                entry.remove = charactersToRemove;\n              }\n            }\n\n            entries.push(entry);\n          }\n\n          rules[ruleCode] = {\n            \"type\": ruleType,\n            \"combineable\": combineable == \"Y\",\n            \"entries\": entries\n          };\n          i += numEntries;\n        } else if (ruleType === \"COMPOUNDRULE\") {\n          numEntries = parseInt(definitionParts[1], 10);\n\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            line = lines[j];\n            lineParts = line.split(/\\s+/);\n            this.compoundRules.push(lineParts[1]);\n          }\n\n          i += numEntries;\n        } else if (ruleType === \"REP\") {\n          lineParts = line.split(/\\s+/);\n\n          if (lineParts.length === 3) {\n            this.replacementTable.push([lineParts[1], lineParts[2]]);\n          }\n        } else {\n          // ONLYINCOMPOUND\n          // COMPOUNDMIN\n          // FLAG\n          // KEEPCASE\n          // NEEDAFFIX\n          this.flags[ruleType] = definitionParts[1];\n        }\n      }\n\n      return rules;\n    },\n\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from an affix file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeAffixComments: function _removeAffixComments(data) {\n      // Remove comments\n      // This used to remove any string starting with '#' up to the end of the line,\n      // but some COMPOUNDRULE definitions include '#' as part of the rule.\n      // I haven't seen any affix files that use comments on the same line as real data,\n      // so I don't think this will break anything.\n      data = data.replace(/^\\s*#.*$/mg, \"\"); // Trim each line\n\n      data = data.replace(/^\\s\\s*/m, '').replace(/\\s\\s*$/m, ''); // Remove blank lines.\n\n      data = data.replace(/\\n{2,}/g, \"\\n\"); // Trim the entire string\n\n      data = data.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n      return data;\n    },\n\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n     */\n    _parseDIC: function _parseDIC(data) {\n      data = this._removeDicComments(data);\n      var lines = data.split(\"\\n\");\n      var dictionaryTable = {};\n\n      function addWord(word, rules) {\n        // Some dictionaries will list the same word multiple times with different rule sets.\n        if (!dictionaryTable.hasOwnProperty(word)) {\n          dictionaryTable[word] = null;\n        }\n\n        if (rules.length > 0) {\n          if (dictionaryTable[word] === null) {\n            dictionaryTable[word] = [];\n          }\n\n          dictionaryTable[word].push(rules);\n        }\n      } // The first line is the number of words in the dictionary.\n\n\n      for (var i = 1, _len = lines.length; i < _len; i++) {\n        var line = lines[i];\n        var parts = line.split(\"/\", 2);\n        var word = parts[0]; // Now for each affix rule, generate that form of the word.\n\n        if (parts.length > 1) {\n          var ruleCodesArray = this.parseRuleCodes(parts[1]); // Save the ruleCodes for compound word situations.\n\n          if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\n            addWord(word, ruleCodesArray);\n          }\n\n          for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n            var code = ruleCodesArray[j];\n            var rule = this.rules[code];\n\n            if (rule) {\n              var newWords = this._applyRule(word, rule);\n\n              for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n                var newWord = newWords[ii];\n                addWord(newWord, []);\n\n                if (rule.combineable) {\n                  for (var k = j + 1; k < _jlen; k++) {\n                    var combineCode = ruleCodesArray[k];\n                    var combineRule = this.rules[combineCode];\n\n                    if (combineRule) {\n                      if (combineRule.combineable && rule.type != combineRule.type) {\n                        var otherNewWords = this._applyRule(newWord, combineRule);\n\n                        for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n                          var otherNewWord = otherNewWords[iii];\n                          addWord(otherNewWord, []);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (code in this.compoundRuleCodes) {\n              this.compoundRuleCodes[code].push(word);\n            }\n          }\n        } else {\n          addWord(word.trim(), []);\n        }\n      }\n\n      return dictionaryTable;\n    },\n\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeDicComments: function _removeDicComments(data) {\n      // I can't find any official documentation on it, but at least the de_DE\n      // dictionary uses tab-indented lines as comments.\n      // Remove comments\n      data = data.replace(/^\\t.*$/mg, \"\");\n      return data;\n    },\n    parseRuleCodes: function parseRuleCodes(textCodes) {\n      if (!textCodes) {\n        return [];\n      } else if (!(\"FLAG\" in this.flags)) {\n        return textCodes.split(\"\");\n      } else if (this.flags.FLAG === \"long\") {\n        var flags = [];\n\n        for (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n          flags.push(textCodes.substr(i, 2));\n        }\n\n        return flags;\n      } else if (this.flags.FLAG === \"num\") {\n        return textCodes.split(\",\");\n      }\n    },\n\n    /**\n     * Applies an affix rule to a word.\n     *\n     * @param {String} word The base word.\n     * @param {Object} rule The affix rule.\n     * @returns {String[]} The new words generated by the rule.\n     */\n    _applyRule: function _applyRule(word, rule) {\n      var entries = rule.entries;\n      var newWords = [];\n\n      for (var i = 0, _len = entries.length; i < _len; i++) {\n        var entry = entries[i];\n\n        if (!entry.match || word.match(entry.match)) {\n          var newWord = word;\n\n          if (entry.remove) {\n            newWord = newWord.replace(entry.remove, \"\");\n          }\n\n          if (rule.type === \"SFX\") {\n            newWord = newWord + entry.add;\n          } else {\n            newWord = entry.add + newWord;\n          }\n\n          newWords.push(newWord);\n\n          if (\"continuationClasses\" in entry) {\n            for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n              var continuationRule = this.rules[entry.continuationClasses[j]];\n\n              if (continuationRule) {\n                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n              }\n              /*\n              else {\n              \t// This shouldn't happen, but it does, at least in the de_DE dictionary.\n              \t// I think the author mistakenly supplied lower-case rule codes instead \n              \t// of upper-case.\n              }\n              */\n\n            }\n          }\n        }\n      }\n\n      return newWords;\n    },\n\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {String} aWord The word to check.\n     * @returns {Boolean}\n     */\n    check: function check(aWord) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      } // Remove leading and trailing whitespace\n\n\n      var trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n      if (this.checkExact(trimmedWord)) {\n        return true;\n      } // The exact word is not in the dictionary.\n\n\n      if (trimmedWord.toUpperCase() === trimmedWord) {\n        // The word was supplied in all uppercase.\n        // Check for a capitalized form of the word.\n        var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n\n        if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        }\n\n        if (this.checkExact(capitalizedWord)) {\n          return true;\n        }\n      }\n\n      var lowercaseWord = trimmedWord.toLowerCase();\n\n      if (lowercaseWord !== trimmedWord) {\n        if (this.hasFlag(lowercaseWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        } // Check for a lowercase form\n\n\n        if (this.checkExact(lowercaseWord)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Checks whether a word exists in the current dictionary.\n     *\n     * @param {String} word The word to check.\n     * @returns {Boolean}\n     */\n    checkExact: function checkExact(word) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      var ruleCodes = this.dictionaryTable[word];\n\n      var i, _len;\n\n      if (typeof ruleCodes === 'undefined') {\n        // Check if this might be a compound word.\n        if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n          for (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n            if (word.match(this.compoundRules[i])) {\n              return true;\n            }\n          }\n        }\n      } else if (ruleCodes === null) {\n        // a null (but not undefined) value for an entry in the dictionary table\n        // means that the word is in the dictionary but has no flags.\n        return true;\n      } else if (typeof ruleCodes === 'object') {\n        // this.dictionary['hasOwnProperty'] will be a function.\n        for (i = 0, _len = ruleCodes.length; i < _len; i++) {\n          if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {String} word The word in question.\n     * @param {String} flag The flag in question.\n     * @return {Boolean}\n     */\n    hasFlag: function hasFlag(word, flag, wordFlags) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      if (flag in this.flags) {\n        if (typeof wordFlags === 'undefined') {\n          wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n        }\n\n        if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Returns a list of suggestions for a misspelled word.\n     *\n     * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n     * This suggestor is primitive, but it works.\n     *\n     * @param {String} word The misspelling.\n     * @param {Number} [limit=5] The maximum number of suggestions to return.\n     * @returns {String[]} The array of suggestions.\n     */\n    alphabet: \"\",\n    suggest: function suggest(word, limit) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      limit = limit || 5;\n\n      if (this.memoized.hasOwnProperty(word)) {\n        var memoizedLimit = this.memoized[word]['limit']; // Only return the cached list if it's big enough or if there weren't enough suggestions\n        // to fill a smaller limit.\n\n        if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n          return this.memoized[word]['suggestions'].slice(0, limit);\n        }\n      }\n\n      if (this.check(word)) return []; // Check the replacement table.\n\n      for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n        var replacementEntry = this.replacementTable[i];\n\n        if (word.indexOf(replacementEntry[0]) !== -1) {\n          var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n\n          if (this.check(correctedWord)) {\n            return [correctedWord];\n          }\n        }\n      }\n\n      var self = this;\n      self.alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n      /*\n      if (!self.alphabet) {\n      \t// Use the alphabet as implicitly defined by the words in the dictionary.\n      \tvar alphaHash = {};\n      \t\n      \tfor (var i in self.dictionaryTable) {\n      \t\tfor (var j = 0, _len = i.length; j < _len; j++) {\n      \t\t\talphaHash[i[j]] = true;\n      \t\t}\n      \t}\n      \t\n      \tfor (var i in alphaHash) {\n      \t\tself.alphabet += i;\n      \t}\n      \t\n      \tvar alphaArray = self.alphabet.split(\"\");\n      \talphaArray.sort();\n      \tself.alphabet = alphaArray.join(\"\");\n      }\n      */\n\n      function edits1(words) {\n        var rv = [];\n\n        var ii, i, j, _iilen, _len, _jlen;\n\n        for (ii = 0, _iilen = words.length; ii < _iilen; ii++) {\n          var word = words[ii];\n\n          for (i = 0, _len = word.length + 1; i < _len; i++) {\n            var s = [word.substring(0, i), word.substring(i)];\n\n            if (s[1]) {\n              rv.push(s[0] + s[1].substring(1));\n            } // Eliminate transpositions of identical letters\n\n\n            if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n              rv.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));\n            }\n\n            if (s[1]) {\n              for (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\n                // Eliminate replacement of a letter by itself\n                if (self.alphabet[j] != s[1].substring(0, 1)) {\n                  rv.push(s[0] + self.alphabet[j] + s[1].substring(1));\n                }\n              }\n            }\n\n            if (s[1]) {\n              for (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\n                rv.push(s[0] + self.alphabet[j] + s[1]);\n              }\n            }\n          }\n        }\n\n        return rv;\n      }\n\n      function known(words) {\n        var rv = [];\n\n        for (var i = 0, _len = words.length; i < _len; i++) {\n          if (self.check(words[i])) {\n            rv.push(words[i]);\n          }\n        }\n\n        return rv;\n      }\n\n      function correct(word) {\n        // Get the edit-distance-1 and edit-distance-2 forms of this word.\n        var ed1 = edits1([word]);\n        var ed2 = edits1(ed1);\n        var corrections = known(ed1.concat(ed2));\n\n        var i, _len; // Sort the edits based on how many different ways they were created.\n\n\n        var weighted_corrections = {};\n\n        for (i = 0, _len = corrections.length; i < _len; i++) {\n          if (!(corrections[i] in weighted_corrections)) {\n            weighted_corrections[corrections[i]] = 1;\n          } else {\n            weighted_corrections[corrections[i]] += 1;\n          }\n        }\n\n        var sorted_corrections = [];\n\n        for (i in weighted_corrections) {\n          if (weighted_corrections.hasOwnProperty(i)) {\n            sorted_corrections.push([i, weighted_corrections[i]]);\n          }\n        }\n\n        function sorter(a, b) {\n          if (a[1] < b[1]) {\n            return -1;\n          }\n\n          return 1;\n        }\n\n        sorted_corrections.sort(sorter).reverse();\n        var rv = [];\n        var capitalization_scheme = \"lowercase\";\n\n        if (word.toUpperCase() === word) {\n          capitalization_scheme = \"uppercase\";\n        } else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n          capitalization_scheme = \"capitalized\";\n        }\n\n        for (i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) {\n          if (\"uppercase\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n          } else if (\"capitalized\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n          }\n\n          if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\")) {\n            rv.push(sorted_corrections[i][0]);\n          }\n        }\n\n        return rv;\n      }\n\n      this.memoized[word] = {\n        'suggestions': correct(word),\n        'limit': limit\n      };\n      return this.memoized[word]['suggestions'];\n    }\n  };\n})(); // Support for use as a node.js module.\n\n\nif (typeof module !== 'undefined') {\n  module.exports = Typo;\n}","map":{"version":3,"sources":["/Users/shayaansaiyed/Documents/Projects/notes-manager/node_modules/typo-js/typo.js"],"names":["Typo","dictionary","affData","wordsData","settings","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","flags","memoized","loaded","self","path","i","j","_len","_jlen","setup","window","chrome","extension","dictionaryPath","readDataFile","getURL","setAffData","setWordsData","__dirname","url","setFunc","response","_readFile","asyncLoad","then","data","_parseAFF","length","rule","ONLYINCOMPOUND","_parseDIC","ruleText","expressionText","character","join","RegExp","loadedCallback","prototype","load","obj","hasOwnProperty","charset","async","XMLHttpRequest","promise","req","open","Promise","resolve","reject","onload","status","responseText","statusText","onerror","overrideMimeType","send","require","fs","existsSync","stats","statSync","fileDescriptor","openSync","buffer","Buffer","size","readSync","toString","console","log","e","line","subline","numEntries","lineParts","_removeAffixComments","lines","split","definitionParts","ruleType","ruleCode","combineable","parseInt","entries","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","replace","_removeDicComments","addWord","word","parts","ruleCodesArray","indexOf","NEEDAFFIX","code","newWords","_applyRule","ii","_iilen","newWord","k","combineCode","combineRule","type","otherNewWords","iii","_iiilen","otherNewWord","trim","textCodes","FLAG","substr","continuationRule","concat","check","aWord","trimmedWord","checkExact","toUpperCase","capitalizedWord","substring","toLowerCase","hasFlag","lowercaseWord","ruleCodes","COMPOUNDMIN","flag","wordFlags","Array","apply","alphabet","suggest","limit","memoizedLimit","slice","replacementEntry","correctedWord","edits1","words","rv","s","known","correct","ed1","ed2","corrections","weighted_corrections","sorted_corrections","sorter","a","b","sort","reverse","capitalization_scheme","Math","min","module","exports"],"mappings":"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","sourcesContent":["/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \n * dictionaries.\n */\n\nvar Typo;\n\n(function () {\n\"use strict\";\n\n/**\n * Typo constructor.\n *\n * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\n *                              \"en_US\". This is only used to auto-load dictionaries.\n * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\n *                              and Typo.js is being used in a Chrome extension, the .aff\n *                              file will be loaded automatically from\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n *                              In other environments, it will be loaded from\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\n *                              and Typo.js is being used in a Chrome extension, the .dic\n *                              file will be loaded automatically from\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n *                              In other environments, it will be loaded from\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n * @param {Object} [settings]   Constructor settings. Available properties are:\n *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\n *                              environment.\n *                              {Object} [flags]: flag information.\n *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n *                              asynchronously.\n *                              {Function} [loadedCallback]: Called when both affData and wordsData\n *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n *                              is the instantiated Typo object.\n *\n * @returns {Typo} A Typo object.\n */\n\nTypo = function (dictionary, affData, wordsData, settings) {\n\tsettings = settings || {};\n\n\tthis.dictionary = null;\n\t\n\tthis.rules = {};\n\tthis.dictionaryTable = {};\n\t\n\tthis.compoundRules = [];\n\tthis.compoundRuleCodes = {};\n\t\n\tthis.replacementTable = [];\n\t\n\tthis.flags = settings.flags || {}; \n\t\n\tthis.memoized = {};\n\n\tthis.loaded = false;\n\t\n\tvar self = this;\n\t\n\tvar path;\n\t\n\t// Loop-control variables.\n\tvar i, j, _len, _jlen;\n\t\n\tif (dictionary) {\n\t\tself.dictionary = dictionary;\n\t\t\n\t\t// If the data is preloaded, just setup the Typo object.\n\t\tif (affData && wordsData) {\n\t\t\tsetup();\n\t\t}\n\t\t// Loading data for Chrome extentions.\n\t\telse if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\n\t\t\tif (settings.dictionaryPath) {\n\t\t\t\tpath = settings.dictionaryPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = \"typo/dictionaries\";\n\t\t\t}\n\t\t\t\n\t\t\tif (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n\t\t\tif (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n\t\t}\n\t\telse {\n\t\t\tif (settings.dictionaryPath) {\n\t\t\t\tpath = settings.dictionaryPath;\n\t\t\t}\n\t\t\telse if (typeof __dirname !== 'undefined') {\n\t\t\t\tpath = __dirname + '/dictionaries';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = './dictionaries';\n\t\t\t}\n\t\t\t\n\t\t\tif (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n\t\t\tif (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n\t\t}\n\t}\n\t\n\tfunction readDataFile(url, setFunc) {\n\t\tvar response = self._readFile(url, null, settings.asyncLoad);\n\t\t\n\t\tif (settings.asyncLoad) {\n\t\t\tresponse.then(function(data) {\n\t\t\t\tsetFunc(data);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tsetFunc(response);\n\t\t}\n\t}\n\n\tfunction setAffData(data) {\n\t\taffData = data;\n\n\t\tif (wordsData) {\n\t\t\tsetup();\n\t\t}\n\t}\n\n\tfunction setWordsData(data) {\n\t\twordsData = data;\n\n\t\tif (affData) {\n\t\t\tsetup();\n\t\t}\n\t}\n\n\tfunction setup() {\n\t\tself.rules = self._parseAFF(affData);\n\t\t\n\t\t// Save the rule codes that are used in compound rules.\n\t\tself.compoundRuleCodes = {};\n\t\t\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n\t\t\tvar rule = self.compoundRules[i];\n\t\t\t\n\t\t\tfor (j = 0, _jlen = rule.length; j < _jlen; j++) {\n\t\t\t\tself.compoundRuleCodes[rule[j]] = [];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n\t\t// will do the work of saving the list of words that are compound-only.\n\t\tif (\"ONLYINCOMPOUND\" in self.flags) {\n\t\t\tself.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n\t\t}\n\t\t\n\t\tself.dictionaryTable = self._parseDIC(wordsData);\n\t\t\n\t\t// Get rid of any codes from the compound rule codes that are never used \n\t\t// (or that were special regex characters).  Not especially necessary... \n\t\tfor (i in self.compoundRuleCodes) {\n\t\t\tif (self.compoundRuleCodes[i].length === 0) {\n\t\t\t\tdelete self.compoundRuleCodes[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build the full regular expressions for each compound rule.\n\t\t// I have a feeling (but no confirmation yet) that this method of \n\t\t// testing for compound words is probably slow.\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n\t\t\tvar ruleText = self.compoundRules[i];\n\t\t\t\n\t\t\tvar expressionText = \"\";\n\t\t\t\n\t\t\tfor (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n\t\t\t\tvar character = ruleText[j];\n\t\t\t\t\n\t\t\t\tif (character in self.compoundRuleCodes) {\n\t\t\t\t\texpressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texpressionText += character;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tself.compoundRules[i] = new RegExp(expressionText, \"i\");\n\t\t}\n\t\t\n\t\tself.loaded = true;\n\t\t\n\t\tif (settings.asyncLoad && settings.loadedCallback) {\n\t\t\tsettings.loadedCallback(self);\n\t\t}\n\t}\n\t\n\treturn this;\n};\n\nTypo.prototype = {\n\t/**\n\t * Loads a Typo instance from a hash of all of the Typo properties.\n\t *\n\t * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n\t */\n\t\n\tload : function (obj) {\n\t\tfor (var i in obj) {\n\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\tthis[i] = obj[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t * Read the contents of a file.\n\t * \n\t * @param {String} path The path (relative) to the file.\n\t * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\n\t * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n\t *        files are read synchronously.\n\t * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n\t *          always returned.\n\t */\n\t\n\t_readFile : function (path, charset, async) {\n\t\tcharset = charset || \"utf8\";\n\t\t\n\t\tif (typeof XMLHttpRequest !== 'undefined') {\n\t\t\tvar promise;\n\t\t\tvar req = new XMLHttpRequest();\n\t\t\treq.open(\"GET\", path, async);\n\t\t\t\n\t\t\tif (async) {\n\t\t\t\tpromise = new Promise(function(resolve, reject) {\n\t\t\t\t\treq.onload = function() {\n\t\t\t\t\t\tif (req.status === 200) {\n\t\t\t\t\t\t\tresolve(req.responseText);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treject(req.statusText);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\treq.onerror = function() {\n\t\t\t\t\t\treject(req.statusText);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\n\t\t\tif (req.overrideMimeType)\n\t\t\t\treq.overrideMimeType(\"text/plain; charset=\" + charset);\n\t\t\n\t\t\treq.send(null);\n\t\t\t\n\t\t\treturn async ? promise : req.responseText;\n\t\t}\n\t\telse if (typeof require !== 'undefined') {\n\t\t\t// Node.js\n\t\t\tvar fs = require(\"fs\");\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (fs.existsSync(path)) {\n\t\t\t\t\tvar stats = fs.statSync(path);\n\t\t\t\t\t\n\t\t\t\t\tvar fileDescriptor = fs.openSync(path, 'r');\n\t\t\t\t\t\n\t\t\t\t\tvar buffer = new Buffer(stats.size);\n\t\t\t\t\t\n\t\t\t\t\tfs.readSync(fileDescriptor, buffer, 0, buffer.length, null);\n\t\t\t\t\t\n\t\t\t\t\treturn buffer.toString(charset, 0, buffer.length);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.log(\"Path \" + path + \" does not exist.\");\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Parse the rules out from a .aff file.\n\t *\n\t * @param {String} data The contents of the affix file.\n\t * @returns object The rules from the file.\n\t */\n\t\n\t_parseAFF : function (data) {\n\t\tvar rules = {};\n\t\t\n\t\tvar line, subline, numEntries, lineParts;\n\t\tvar i, j, _len, _jlen;\n\t\t\n\t\t// Remove comment lines\n\t\tdata = this._removeAffixComments(data);\n\t\t\n\t\tvar lines = data.split(\"\\n\");\n\t\t\n\t\tfor (i = 0, _len = lines.length; i < _len; i++) {\n\t\t\tline = lines[i];\n\t\t\t\n\t\t\tvar definitionParts = line.split(/\\s+/);\n\t\t\t\n\t\t\tvar ruleType = definitionParts[0];\n\t\t\t\n\t\t\tif (ruleType == \"PFX\" || ruleType == \"SFX\") {\n\t\t\t\tvar ruleCode = definitionParts[1];\n\t\t\t\tvar combineable = definitionParts[2];\n\t\t\t\tnumEntries = parseInt(definitionParts[3], 10);\n\t\t\t\t\n\t\t\t\tvar entries = [];\n\t\t\t\t\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n\t\t\t\t\tsubline = lines[j];\n\t\t\t\t\t\n\t\t\t\t\tlineParts = subline.split(/\\s+/);\n\t\t\t\t\tvar charactersToRemove = lineParts[2];\n\t\t\t\t\t\n\t\t\t\t\tvar additionParts = lineParts[3].split(\"/\");\n\t\t\t\t\t\n\t\t\t\t\tvar charactersToAdd = additionParts[0];\n\t\t\t\t\tif (charactersToAdd === \"0\") charactersToAdd = \"\";\n\t\t\t\t\t\n\t\t\t\t\tvar continuationClasses = this.parseRuleCodes(additionParts[1]);\n\t\t\t\t\t\n\t\t\t\t\tvar regexToMatch = lineParts[4];\n\t\t\t\t\t\n\t\t\t\t\tvar entry = {};\n\t\t\t\t\tentry.add = charactersToAdd;\n\t\t\t\t\t\n\t\t\t\t\tif (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n\t\t\t\t\t\n\t\t\t\t\tif (regexToMatch !== \".\") {\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\n\t\t\t\t\t\t\tentry.match = new RegExp(regexToMatch + \"$\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tentry.match = new RegExp(\"^\" + regexToMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (charactersToRemove != \"0\") {\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\n\t\t\t\t\t\t\tentry.remove = new RegExp(charactersToRemove  + \"$\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tentry.remove = charactersToRemove;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trules[ruleCode] = { \"type\" : ruleType, \"combineable\" : (combineable == \"Y\"), \"entries\" : entries };\n\t\t\t\t\n\t\t\t\ti += numEntries;\n\t\t\t}\n\t\t\telse if (ruleType === \"COMPOUNDRULE\") {\n\t\t\t\tnumEntries = parseInt(definitionParts[1], 10);\n\t\t\t\t\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n\t\t\t\t\tline = lines[j];\n\t\t\t\t\t\n\t\t\t\t\tlineParts = line.split(/\\s+/);\n\t\t\t\t\tthis.compoundRules.push(lineParts[1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti += numEntries;\n\t\t\t}\n\t\t\telse if (ruleType === \"REP\") {\n\t\t\t\tlineParts = line.split(/\\s+/);\n\t\t\t\t\n\t\t\t\tif (lineParts.length === 3) {\n\t\t\t\t\tthis.replacementTable.push([ lineParts[1], lineParts[2] ]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// ONLYINCOMPOUND\n\t\t\t\t// COMPOUNDMIN\n\t\t\t\t// FLAG\n\t\t\t\t// KEEPCASE\n\t\t\t\t// NEEDAFFIX\n\t\t\t\t\n\t\t\t\tthis.flags[ruleType] = definitionParts[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn rules;\n\t},\n\t\n\t/**\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\n\t *\n\t * @param {String} data The data from an affix file.\n\t * @return {String} The cleaned-up data.\n\t */\n\t\n\t_removeAffixComments : function (data) {\n\t\t// Remove comments\n\t\t// This used to remove any string starting with '#' up to the end of the line,\n\t\t// but some COMPOUNDRULE definitions include '#' as part of the rule.\n\t\t// I haven't seen any affix files that use comments on the same line as real data,\n\t\t// so I don't think this will break anything.\n\t\tdata = data.replace(/^\\s*#.*$/mg, \"\");\n\t\t\n\t\t// Trim each line\n\t\tdata = data.replace(/^\\s\\s*/m, '').replace(/\\s\\s*$/m, '');\n\t\t\n\t\t// Remove blank lines.\n\t\tdata = data.replace(/\\n{2,}/g, \"\\n\");\n\t\t\n\t\t// Trim the entire string\n\t\tdata = data.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t\n\t\treturn data;\n\t},\n\t\n\t/**\n\t * Parses the words out from the .dic file.\n\t *\n\t * @param {String} data The data from the dictionary file.\n\t * @returns object The lookup table containing all of the words and\n\t *                 word forms from the dictionary.\n\t */\n\t\n\t_parseDIC : function (data) {\n\t\tdata = this._removeDicComments(data);\n\t\t\n\t\tvar lines = data.split(\"\\n\");\n\t\tvar dictionaryTable = {};\n\t\t\n\t\tfunction addWord(word, rules) {\n\t\t\t// Some dictionaries will list the same word multiple times with different rule sets.\n\t\t\tif (!dictionaryTable.hasOwnProperty(word)) {\n\t\t\t\tdictionaryTable[word] = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (rules.length > 0) {\n\t\t\t\tif (dictionaryTable[word] === null) {\n\t\t\t\t\tdictionaryTable[word] = [];\n\t\t\t\t}\n\n\t\t\t\tdictionaryTable[word].push(rules);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// The first line is the number of words in the dictionary.\n\t\tfor (var i = 1, _len = lines.length; i < _len; i++) {\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tvar parts = line.split(\"/\", 2);\n\t\t\t\n\t\t\tvar word = parts[0];\n\n\t\t\t// Now for each affix rule, generate that form of the word.\n\t\t\tif (parts.length > 1) {\n\t\t\t\tvar ruleCodesArray = this.parseRuleCodes(parts[1]);\n\t\t\t\t\n\t\t\t\t// Save the ruleCodes for compound word situations.\n\t\t\t\tif (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\n\t\t\t\t\taddWord(word, ruleCodesArray);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n\t\t\t\t\tvar code = ruleCodesArray[j];\n\t\t\t\t\t\n\t\t\t\t\tvar rule = this.rules[code];\n\t\t\t\t\t\n\t\t\t\t\tif (rule) {\n\t\t\t\t\t\tvar newWords = this._applyRule(word, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n\t\t\t\t\t\t\tvar newWord = newWords[ii];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddWord(newWord, []);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (rule.combineable) {\n\t\t\t\t\t\t\t\tfor (var k = j + 1; k < _jlen; k++) {\n\t\t\t\t\t\t\t\t\tvar combineCode = ruleCodesArray[k];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvar combineRule = this.rules[combineCode];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (combineRule) {\n\t\t\t\t\t\t\t\t\t\tif (combineRule.combineable && (rule.type != combineRule.type)) {\n\t\t\t\t\t\t\t\t\t\t\tvar otherNewWords = this._applyRule(newWord, combineRule);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tfor (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar otherNewWord = otherNewWords[iii];\n\t\t\t\t\t\t\t\t\t\t\t\taddWord(otherNewWord, []);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (code in this.compoundRuleCodes) {\n\t\t\t\t\t\tthis.compoundRuleCodes[code].push(word);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddWord(word.trim(), []);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dictionaryTable;\n\t},\n\t\n\t\n\t/**\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\n\t *\n\t * @param {String} data The data from a .dic file.\n\t * @return {String} The cleaned-up data.\n\t */\n\t\n\t_removeDicComments : function (data) {\n\t\t// I can't find any official documentation on it, but at least the de_DE\n\t\t// dictionary uses tab-indented lines as comments.\n\t\t\n\t\t// Remove comments\n\t\tdata = data.replace(/^\\t.*$/mg, \"\");\n\t\t\n\t\treturn data;\n\t},\n\t\n\tparseRuleCodes : function (textCodes) {\n\t\tif (!textCodes) {\n\t\t\treturn [];\n\t\t}\n\t\telse if (!(\"FLAG\" in this.flags)) {\n\t\t\treturn textCodes.split(\"\");\n\t\t}\n\t\telse if (this.flags.FLAG === \"long\") {\n\t\t\tvar flags = [];\n\t\t\t\n\t\t\tfor (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n\t\t\t\tflags.push(textCodes.substr(i, 2));\n\t\t\t}\n\t\t\t\n\t\t\treturn flags;\n\t\t}\n\t\telse if (this.flags.FLAG === \"num\") {\n\t\t\treturn textCodes.split(\",\");\n\t\t}\n\t},\n\t\n\t/**\n\t * Applies an affix rule to a word.\n\t *\n\t * @param {String} word The base word.\n\t * @param {Object} rule The affix rule.\n\t * @returns {String[]} The new words generated by the rule.\n\t */\n\t\n\t_applyRule : function (word, rule) {\n\t\tvar entries = rule.entries;\n\t\tvar newWords = [];\n\t\t\n\t\tfor (var i = 0, _len = entries.length; i < _len; i++) {\n\t\t\tvar entry = entries[i];\n\t\t\t\n\t\t\tif (!entry.match || word.match(entry.match)) {\n\t\t\t\tvar newWord = word;\n\t\t\t\t\n\t\t\t\tif (entry.remove) {\n\t\t\t\t\tnewWord = newWord.replace(entry.remove, \"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rule.type === \"SFX\") {\n\t\t\t\t\tnewWord = newWord + entry.add;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewWord = entry.add + newWord;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnewWords.push(newWord);\n\t\t\t\t\n\t\t\t\tif (\"continuationClasses\" in entry) {\n\t\t\t\t\tfor (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n\t\t\t\t\t\tvar continuationRule = this.rules[entry.continuationClasses[j]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (continuationRule) {\n\t\t\t\t\t\t\tnewWords = newWords.concat(this._applyRule(newWord, continuationRule));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// This shouldn't happen, but it does, at least in the de_DE dictionary.\n\t\t\t\t\t\t\t// I think the author mistakenly supplied lower-case rule codes instead \n\t\t\t\t\t\t\t// of upper-case.\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newWords;\n\t},\n\t\n\t/**\n\t * Checks whether a word or a capitalization variant exists in the current dictionary.\n\t * The word is trimmed and several variations of capitalizations are checked.\n\t * If you want to check a word without any changes made to it, call checkExact()\n\t *\n\t * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n\t *\n\t * @param {String} aWord The word to check.\n\t * @returns {Boolean}\n\t */\n\t\n\tcheck : function (aWord) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\t\t\n\t\t// Remove leading and trailing whitespace\n\t\tvar trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t\n\t\tif (this.checkExact(trimmedWord)) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// The exact word is not in the dictionary.\n\t\tif (trimmedWord.toUpperCase() === trimmedWord) {\n\t\t\t// The word was supplied in all uppercase.\n\t\t\t// Check for a capitalized form of the word.\n\t\t\tvar capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n\t\t\t\n\t\t\tif (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n\t\t\t\t// Capitalization variants are not allowed for this word.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.checkExact(capitalizedWord)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar lowercaseWord = trimmedWord.toLowerCase();\n\t\t\n\t\tif (lowercaseWord !== trimmedWord) {\n\t\t\tif (this.hasFlag(lowercaseWord, \"KEEPCASE\")) {\n\t\t\t\t// Capitalization variants are not allowed for this word.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// Check for a lowercase form\n\t\t\tif (this.checkExact(lowercaseWord)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Checks whether a word exists in the current dictionary.\n\t *\n\t * @param {String} word The word to check.\n\t * @returns {Boolean}\n\t */\n\t\n\tcheckExact : function (word) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tvar ruleCodes = this.dictionaryTable[word];\n\t\t\n\t\tvar i, _len;\n\t\t\n\t\tif (typeof ruleCodes === 'undefined') {\n\t\t\t// Check if this might be a compound word.\n\t\t\tif (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n\t\t\t\tfor (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n\t\t\t\t\tif (word.match(this.compoundRules[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ruleCodes === null) {\n\t\t\t// a null (but not undefined) value for an entry in the dictionary table\n\t\t\t// means that the word is in the dictionary but has no flags.\n\t\t\treturn true;\n\t\t}\n\t\telse if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n\t\t\tfor (i = 0, _len = ruleCodes.length; i < _len; i++) {\n\t\t\t\tif (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Looks up whether a given word is flagged with a given flag.\n\t *\n\t * @param {String} word The word in question.\n\t * @param {String} flag The flag in question.\n\t * @return {Boolean}\n\t */\n\t \n\thasFlag : function (word, flag, wordFlags) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tif (flag in this.flags) {\n\t\t\tif (typeof wordFlags === 'undefined') {\n\t\t\t\twordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n\t\t\t}\n\t\t\t\n\t\t\tif (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Returns a list of suggestions for a misspelled word.\n\t *\n\t * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n\t * This suggestor is primitive, but it works.\n\t *\n\t * @param {String} word The misspelling.\n\t * @param {Number} [limit=5] The maximum number of suggestions to return.\n\t * @returns {String[]} The array of suggestions.\n\t */\n\t\n\talphabet : \"\",\n\t\n\tsuggest : function (word, limit) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tlimit = limit || 5;\n\n\t\tif (this.memoized.hasOwnProperty(word)) {\n\t\t\tvar memoizedLimit = this.memoized[word]['limit'];\n\n\t\t\t// Only return the cached list if it's big enough or if there weren't enough suggestions\n\t\t\t// to fill a smaller limit.\n\t\t\tif (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n\t\t\t\treturn this.memoized[word]['suggestions'].slice(0, limit);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.check(word)) return [];\n\t\t\n\t\t// Check the replacement table.\n\t\tfor (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n\t\t\tvar replacementEntry = this.replacementTable[i];\n\t\t\t\n\t\t\tif (word.indexOf(replacementEntry[0]) !== -1) {\n\t\t\t\tvar correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n\t\t\t\t\n\t\t\t\tif (this.check(correctedWord)) {\n\t\t\t\t\treturn [ correctedWord ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar self = this;\n\t\tself.alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\t\t\n\t\t/*\n\t\tif (!self.alphabet) {\n\t\t\t// Use the alphabet as implicitly defined by the words in the dictionary.\n\t\t\tvar alphaHash = {};\n\t\t\t\n\t\t\tfor (var i in self.dictionaryTable) {\n\t\t\t\tfor (var j = 0, _len = i.length; j < _len; j++) {\n\t\t\t\t\talphaHash[i[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i in alphaHash) {\n\t\t\t\tself.alphabet += i;\n\t\t\t}\n\t\t\t\n\t\t\tvar alphaArray = self.alphabet.split(\"\");\n\t\t\talphaArray.sort();\n\t\t\tself.alphabet = alphaArray.join(\"\");\n\t\t}\n\t\t*/\n\t\t\n\t\tfunction edits1(words) {\n\t\t\tvar rv = [];\n\t\t\t\n\t\t\tvar ii, i, j, _iilen, _len, _jlen;\n\t\t\t\n\t\t\tfor (ii = 0, _iilen = words.length; ii < _iilen; ii++) {\n\t\t\t\tvar word = words[ii];\n\t\t\t\t\n\t\t\t\tfor (i = 0, _len = word.length + 1; i < _len; i++) {\n\t\t\t\t\tvar s = [ word.substring(0, i), word.substring(i) ];\n\t\t\t\t\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\trv.push(s[0] + s[1].substring(1));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Eliminate transpositions of identical letters\n\t\t\t\t\tif (s[1].length > 1 && s[1][1] !== s[1][0]) {\n\t\t\t\t\t\trv.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\tfor (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\n\t\t\t\t\t\t\t// Eliminate replacement of a letter by itself\n\t\t\t\t\t\t\tif (self.alphabet[j] != s[1].substring(0,1)){\n\t\t\t\t\t\t\t\trv.push(s[0] + self.alphabet[j] + s[1].substring(1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\tfor (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {\n\t\t\t\t\t\t\trv.push(s[0] + self.alphabet[j] + s[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn rv;\n\t\t}\n\t\t\n\t\tfunction known(words) {\n\t\t\tvar rv = [];\n\t\t\t\n\t\t\tfor (var i = 0, _len = words.length; i < _len; i++) {\n\t\t\t\tif (self.check(words[i])) {\n\t\t\t\t\trv.push(words[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn rv;\n\t\t}\n\t\t\n\t\tfunction correct(word) {\n\t\t\t// Get the edit-distance-1 and edit-distance-2 forms of this word.\n\t\t\tvar ed1 = edits1([word]);\n\t\t\tvar ed2 = edits1(ed1);\n\t\t\t\n\t\t\tvar corrections = known(ed1.concat(ed2));\n\t\t\t\n\t\t\tvar i, _len;\n\t\t\t\n\t\t\t// Sort the edits based on how many different ways they were created.\n\t\t\tvar weighted_corrections = {};\n\t\t\t\n\t\t\tfor (i = 0, _len = corrections.length; i < _len; i++) {\n\t\t\t\tif (!(corrections[i] in weighted_corrections)) {\n\t\t\t\t\tweighted_corrections[corrections[i]] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tweighted_corrections[corrections[i]] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sorted_corrections = [];\n\t\t\t\n\t\t\tfor (i in weighted_corrections) {\n\t\t\t\tif (weighted_corrections.hasOwnProperty(i)) {\n\t\t\t\t\tsorted_corrections.push([ i, weighted_corrections[i] ]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction sorter(a, b) {\n\t\t\t\tif (a[1] < b[1]) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\tsorted_corrections.sort(sorter).reverse();\n\t\t\t\n\t\t\tvar rv = [];\n\n\t\t\tvar capitalization_scheme = \"lowercase\";\n\t\t\t\n\t\t\tif (word.toUpperCase() === word) {\n\t\t\t\tcapitalization_scheme = \"uppercase\";\n\t\t\t}\n\t\t\telse if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n\t\t\t\tcapitalization_scheme = \"capitalized\";\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) {\n\t\t\t\tif (\"uppercase\" === capitalization_scheme) {\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n\t\t\t\t}\n\t\t\t\telse if (\"capitalized\" === capitalization_scheme) {\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\")) {\n\t\t\t\t\trv.push(sorted_corrections[i][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn rv;\n\t\t}\n\t\t\n\t\tthis.memoized[word] = {\n\t\t\t'suggestions': correct(word),\n\t\t\t'limit': limit\n\t\t};\n\n\t\treturn this.memoized[word]['suggestions'];\n\t}\n};\n})();\n\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n\tmodule.exports = Typo;\n}"]},"metadata":{},"sourceType":"script"}